---
title: "Relative Informativity of Different Socio-Indexical Factors for Vowel Categorization"
subtitle: "An Analysis of the Nationwide Speech Corpus Vowel Data"
author:
- "Kodi Weatherholtz"
- "(Modified by Dave Kleinschmidt)"
date: "April 25, 2016"
output:
  html_document:
    number_sections: true
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---


```{r preamble, cache=FALSE, warning=FALSE, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(cache = TRUE,
                      warning = FALSE, 
                      message = FALSE,
                      dev = c('png', 'pdf', 'svg'),
                      fig.width = 9,
                      fig.height = 3)
```


# Data initialization
```{r data-initialization}

# load relevant packages
library(dplyr)
library(tidyr)
library(mvtnorm)
library(ggplot2)
library(ggthemes)
library(cowplot)
library(psych)
library(phonR) # contains functions for vowel normalization
library(Cairo) # for saving plots with special characters (e.g., IPA)


theme_1 <- theme_bw() +
  theme(panel.border = element_blank(),
        legend.position = "top",
        legend.background = element_rect(colour = "grey"),
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.x = element_blank())


# load hVd vowel data from Nationwide Speech Project
devtools::load_all()
data('nsp_vows', package='nspvowels')

# add Lobanov-normalized (z-scored) F1 and F2 values
nsp_vows <- nsp_vows %>%
  group_by(Talker) %>%
  mutate(
    F1.Lobanov = as.numeric(normLobanov(F1)),
    F2.Lobanov = as.numeric(normLobanov(F2)))
```

```{r}
print.data.frame(head(nsp_vows))

xtabs(~ Sex + Dialect, subset(nsp_vows, !duplicated(Talker)))

levels(nsp_vows$Vowel)
```

# Generative model parameters {.tabset .tabset-fade}
The NSP hVd vowel corpus only contains acoustic measurements for the first two formants. Thus, for the purposes of the current analysis, we assume vowel categories can be approximated as multivariate normal distributions in F~1~xF~2~ space. We start by identifying the parameters that define these multivariate distributions (i.e., F~1~ and F~2~ means, variances and covariance) at different levels of specificity: by talker, by gender, by dialect, by *both* gender and dialect, or marginalizing across all socio-indexical variables.

## raw F~1~xF~2~ distributional statistics
```{r generative-model-parameters}

speaker_model <- nsp_vows %>% group_by(Talker) %>% train_models()
gender_model <- nsp_vows %>% group_by(Sex) %>% train_models()
dialect_model <- nsp_vows %>% group_by(Dialect) %>% train_models()
genderByDialect_model <- nsp_vows %>% group_by(Sex, Dialect) %>% train_models()
marginal_model <- nsp_vows %>% group_by() %>% train_models()

```

## Lobanov-normalized (z-scored) F~1~xF~2~ distributional statistics
```{r}

train_models_lobanov <- function(d, ...) 
  train_models(d, formants = c("F1.Lobanov", "F2.Lobanov"), ...)

speaker_model_Ln <- 
  nsp_vows %>% group_by(Talker) %>% train_models_lobanov()
gender_model_Ln <-
  nsp_vows %>% group_by(Sex) %>% train_models_lobanov()
dialect_model_Ln <-
  nsp_vows %>% group_by(Dialect) %>% train_models_lobanov()
genderByDialect_model_Ln <-
  nsp_vows %>% group_by(Sex, Dialect) %>% train_models_lobanov()
marginal_model_Ln <-
  nsp_vows %>% group_by() %>% train_models_lobanov()


```

# Informativity with respect to cue distributions {.tabset .tabset-fade}
...

## Analysis code
```{r KL-divergence}

kl_from_marginal <- function(models, description, ref_models = marginal_model) {
  left_join(models, ref_models, by='Vowel') %>%
    mutate(KL = map2_dbl(model.x, model.y, nspvowels::KL_mods),
           KL.desc = description)
}

KL_talker <- speaker_model %>% kl_from_marginal("conditioned\non talker")
KL_gender <- gender_model %>% kl_from_marginal("conditioned\non gender")
KL_dialect <- dialect_model %>% kl_from_marginal("conditioned\non dialect")
KL_genderByDialect <- genderByDialect_model %>% kl_from_marginal("conditioned\non gender and dialect")

kl_from_marginal_lobanov <- 
  function(...) kl_from_marginal(..., ref_models = marginal_model_Ln)

KL_talker_Ln <-
  speaker_model_Ln %>% kl_from_marginal_lobanov("conditioned\non talker")
KL_gender_Ln <-
  gender_model_Ln %>% kl_from_marginal_lobanov("conditioned\non gender")
KL_dialect_Ln <-
  dialect_model_Ln %>% kl_from_marginal_lobanov("conditioned\non dialect")
KL_genderByDialect_Ln <-
  genderByDialect_model_Ln %>% kl_from_marginal_lobanov("conditioned\non gender and dialect")

```

## Graphing code
```{r}
library(gtools)
library(scales)

KL_combined <- bind_rows(KL_talker,
                         KL_gender,
                         KL_dialect,
                         KL_genderByDialect
                         )

KL_combined_Ln <- bind_rows(KL_talker_Ln,
                            KL_gender_Ln,
                            KL_dialect_Ln,
                            KL_genderByDialect_Ln
                            )

KL_legend_title <- "Difference between the marginal F1xF2 distribution and the\ncorresponding distribution _______________"

p_kl <- KL_combined %>%
  filter(!is.na(KL)) %>%
  ggplot(aes(x = Vowel,
             y = KL,
             colour = Vowel, fill = Vowel,
             group = KL.desc, alpha = KL.desc)) +
  stat_summary(fun.y = "mean", geom = "bar", 
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_cl_boot", geom = "pointrange", 
               position = position_dodge(.9),
               alpha = 1, colour = "grey30") +
  stat_summary(fun.y = "mean", geom = "point", 
               position = position_dodge(.9),
               alpha = 1,
               show.legend = FALSE) +
  scale_y_continuous("KL divergence (in bits)", expand = c(0,0)) +
  scale_alpha_manual(KL_legend_title, values = c(.4, .6, .8, .95)) +
  guides(fill = FALSE, colour = FALSE,
         alpha = guide_legend(title.position = "top")) +
  coord_cartesian(ylim = c(0,6.3)) +
  geom_rangeframe(colour = "black", alpha = 1) +
  theme_1

p_kl_ln <- KL_combined_Ln %>%
  filter(!is.na(KL)) %>%
  ggplot(aes(x = Vowel,
             y = KL,
             colour = Vowel, fill = Vowel,
             group = KL.desc, alpha = KL.desc)) +
  stat_summary(fun.y = "mean", geom = "bar", 
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_cl_boot", geom = "pointrange", 
               position = position_dodge(.9),
               alpha = 1, colour = "grey30") +
  stat_summary(fun.y = "mean", geom = "point", 
               position = position_dodge(.9),
               alpha = 1,
               show.legend = FALSE) +
  scale_y_continuous("KL divergence (in bits)", expand = c(0,0)) +
  scale_alpha_manual(KL_legend_title, values = c(.4, .6, .8, .95)) +
  guides(fill = FALSE, colour = FALSE,
         alpha = guide_legend(title.position = "top")) +
  coord_cartesian(ylim = c(0,6.3)) +
  geom_rangeframe(colour = "black", alpha = 1) +
  theme_1
```


## Graphs
```{r kl-plots, fig.height = 8}
grobs <- ggplotGrob(p_kl + theme(legend.position="bottom"))$grobs
legend_b <- grobs[[which(sapply(grobs, function(x) x$name) == "guide-box")]]

plot_grid(legend_b, 
          p_kl + 
            theme(legend.position = "none"), 
          p_kl_ln + 
            theme(legend.position = "none"), 
          labels = c("", 
                     "A (input = F1xF2 (Hz))", 
                     "B (input = Lobanov-normalized F1xF2)"),
          label_size = 13,
          hjust = 0,
          vjust = 0,
          nrow = 3, 
          rel_heights = c(.2, 1, 1))

```



# Informativity with respect to categorization {.tabset .tabset-fade}
Here we calculate the probability of correctly categorizing each vowel token in the `nsp_vows` dataframe under different generative models:

**Generative models:**

1. marginal model: <br> p(vowel category | F~1~xF~2~) 

2. dialect-specific model: <br> p(vowel category | F~1~xF~2~, dialect)

3. gender-specific model: <br> p(vowel category | F~1~xF~2~, gender)

4. dialect- and gender-specific model: <br> p(vowel category | F~1~xF~2~, gender, dialect)

5. talker-specific model: <br> p(vowel category | F~1~xF~2~, talker identity)

**Assumptions:**

- categorization = selecting category with highest posterior probability, given the input
- uniform prior probability across vowels
- perfect knowledge of talker- or group-specific distributional statistics
- perfect certainty about gender/dialect/talker identity

## Analysis code
```{r prob-correct-under-each-generative-model}
## ----------------------------------------------
# calculate probability and log-odds correct for each 
# vowel token under the different models and store 
# the results in the same data.frame
## ----------------------------------------------

class_hz <-
  map2(c('talker',
         'gender',
         'dialect',
         'genderByDialect',
         'marginal'),
       list(speaker_model,
            gender_model,
            dialect_model,
            genderByDialect_model,
            marginal_model),
       ~ classify_mods(nsp_vows, .y) %>% mutate(model = .x)) %>%
  bind_rows()

class_Ln <-
  map2(c('talker',
         'gender',
         'dialect',
         'genderByDialect',
         'marginal'),
       list(speaker_model_Ln,
            gender_model_Ln,
            dialect_model_Ln,
            genderByDialect_model_Ln,
            marginal_model_Ln),
       ~ classify_mods(nsp_vows, .y) %>% mutate(model = .x)) %>%
  bind_rows()



```

## Graphing code
```{r}
## --------------------------------- 
# define variables for quick conversion of factor levels

model_names <- data_frame(model = c('marginal',
                                    'dialect',
                                    'gender',
                                    'genderByDialect',
                                    'talker'),
                          generative_model = 
                            c("marginal",
                              "conditioned\non dialect",
                              "conditioned\non gender",
                              "conditioned\non dialect and gender",
                              "conditioned\non talker identity")) %>%
  mutate(generative_model = factor(generative_model, levels=generative_model))


## --------------------------------- 
# average probability of recognizing each vowel (using criterion rule)
# under various generative models
## --------------------------------- 

p_hz <- class_hz %>%
  mutate(correct_recog = as.numeric(correct)) %>%
  left_join(model_names) %>%
  ggplot(aes(x = Vowel, 
             y = correct_recog, 
             fill = Vowel,
             colour = Vowel,
             group = generative_model,
             #colour = generative_model, 
             alpha = generative_model)) + 
  stat_summary(fun.y = "mean", geom = "bar", 
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_cl_boot", geom = "pointrange", 
               position = position_dodge(.9),
               alpha = 1, colour = "grey30") +
  stat_summary(fun.y = "mean", geom = "point", 
               position = position_dodge(.9),
               aes(colour = Vowel),
               alpha = 1,
               show.legend = FALSE) +
  scale_y_continuous("Probability of correct recognition") +
  scale_alpha_manual(values = c(.2, .4, .6, .8, .95)) +
  guides(fill = FALSE, colour = FALSE) +
  coord_cartesian(ylim = c(.38, 1)) +
  geom_rangeframe(colour = "black", alpha = 1) +
  theme_1


p_Ln <- class_Ln %>%
  mutate(correct_recog = as.numeric(correct)) %>%
  left_join(model_names) %>%
  ggplot(aes(x = Vowel, 
             y = correct_recog, 
             fill = Vowel,
             colour = Vowel,
             group = generative_model,
             alpha = generative_model)) + 
  stat_summary(fun.y = "mean", geom = "bar", 
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_cl_boot", geom = "pointrange", 
               position = position_dodge(.9),
               alpha = 1, colour = "grey30") +
  stat_summary(fun.y = "mean", geom = "point", 
               position = position_dodge(.9),
               aes(colour = Vowel),
               alpha = 1,
               show.legend = FALSE) +
  scale_y_continuous("Probability of correct recognition") +
  scale_alpha_manual(values = c(.2, .4, .6, .8, .95)) +
  guides(fill = FALSE, colour = FALSE) +
  coord_cartesian(ylim = c(.38, 1)) +
  geom_rangeframe(colour = "black", alpha = 1) +
  theme_1
```


## Graphs
```{r correct-recog-plots, fig.height = 8}
grobs <- ggplotGrob(p_hz + theme(legend.position="bottom"))$grobs
legend_b <- grobs[[which(sapply(grobs, function(x) x$name) == "guide-box")]]

plot_grid(legend_b, 
          p_hz + theme(legend.position = "none"), 
          p_Ln + theme(legend.position = "none"), 
          labels = c("", 
                     "A (input = F1xF2 (Hz))", 
                     "B (input = Lobanov-normalized F1xF2)"),
          label_size = 13,
          hjust = 0,
          vjust = 0.5,
          nrow = 3, 
          rel_heights = c(.2, 1, 1))

```


